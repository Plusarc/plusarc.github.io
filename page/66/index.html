<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="google88d81a02a91db82f" />










  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="Plusaber&apos;s Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Plusaber's Blog">
<meta property="og:url" content="http://yoursite.com/page/66/index.html">
<meta property="og:site_name" content="Plusaber's Blog">
<meta property="og:description" content="Plusaber&apos;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Plusaber's Blog">
<meta name="twitter:description" content="Plusaber&apos;s Blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/66/"/>


  <title> Plusaber's Blog </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-hk">

  


<!-- hexo-inject:begin --><!-- hexo-inject:end --><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-79158075-1', 'auto');
  ga('send', 'pageview');
</script>









  
  
    
  

  <div class="container one-collumn sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Plusaber's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/05/10/Design Pattern_Principal/" itemprop="url">
                  架构中的设计原则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2014-05-10T00:00:00+09:00" content="2014-05-10">
              2014-05-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Design-Pattern/" itemprop="url" rel="index">
                    <span itemprop="name">Design Pattern</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/05/10/Design Pattern_Principal/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/05/10/Design Pattern_Principal/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="架构中的设计原则"><a href="#架构中的设计原则" class="headerlink" title="架构中的设计原则"></a>架构中的设计原则</h1><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则核心思想就是：系统中的每一个对象应该有且只有一个单独的职责，而所有对象对象所关注的iu是自身职责的完成，也就是Single responsibility principle，也就是为了达成高内聚、低耦合。</p>
<p>通常一个类的职责越多，导致其变化的因素也就越多，其变化会影响到的类也越多。当这个类的某个职责发生变化，会导致类的其他部分受到影响，也就是程序的脆弱和僵硬。解决这种的问题的方法就是分耦。</p>
<h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><p>里氏替换原则的核心思想就是：任何父类出现的地方都可以用它的子类来替代。</p>
<p>里氏替换的意思就是：同一个继承体系中的对象应该有共同的行为特征。里氏替换原则关注怎样良好的使用继承，也就是不滥用继承，它是继承复用的基石。具体有下面四点要求：</p>
<ol>
<li>子类必须完全实现父类的方法</li>
<li>子类可以有自己的特性</li>
<li>覆盖或者实现父类的方法时输入参数可以被放大</li>
<li>覆盖或者实现父类的方法时输出结果可以被缩小</li>
</ol>
<h2 id="依赖注入原则"><a href="#依赖注入原则" class="headerlink" title="依赖注入原则"></a>依赖注入原则</h2><p>依赖注入原则的核心思想就是：要依赖于抽象，不要依赖于具体的实现。</p>
<p>依赖注入原则的意思就是：在应用程序中，所有的类如果使用或依赖于其他的类，则都应该依赖于这些其他类的抽象类，而不是这些其他类的具体实现类。抽象层次应该不依赖于具体的实现细节（具体实现类），这样才能保证系统的可复用性和可维护性。为了实现这一点，要求开发人员在编程时针对接口编程，而不针对实现编程。</p>
<p>通过抽线使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。使用如下三种方式来实现：</p>
<ol>
<li>通过构造函数传递依赖对象<br>如在构造函数中的需要传递的参数是抽象类或者接口的方式实现</li>
<li>通过setter方法传递依赖对象</li>
<li>接口声明实现依赖对象</li>
</ol>
<h2 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h2><p>接口分离原则的核心思想就是：不应该使一个接口涵盖不需要使用的方法，也就是一个接口不需要提供太多的行为，只应该提供一种对外的功能，不应该把所有的操作都封装到一个接口中。</p>
<p>这里的接口不仅仅是通过interface定义的接口，也包括对象接口，也就是对象所在的类（类似于单一职责原则）。不同的是，单一职责原则要求的是雷和方法的职责单一，注重的是业务逻辑上的划分，而接口分离原则要求的是接口方法经历少，针对一个模块尽量有用。</p>
<h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><p>核心思想：一个对象应当对其他对象尽可能少地了解。意思就是降低各个对象之间的耦合。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>核心思想：对扩展开放，对修改关闭。也就是对类的改动应该是通过增加代码进行的，而不是改动现有代码。</p>
<p>开闭原则是对前五种原则的一个抽象总结，前五种原则是开闭原则的一些具体实现。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/04/13/Blogging_Summary/" itemprop="url">
                  Blogging参考资料
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2014-04-13T00:00:00+09:00" content="2014-04-13">
              2014-04-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Blogging/" itemprop="url" rel="index">
                    <span itemprop="name">Blogging</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/04/13/Blogging_Summary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/04/13/Blogging_Summary/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Blogging参考资料"><a href="#Blogging参考资料" class="headerlink" title="Blogging参考资料"></a>Blogging参考资料</h1><p>Welcome to my blog, I am Zebang Chen. Here are some tools I use to write blog.</p>
<ol>
<li><a href="http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/" target="_blank" rel="external">Mathjax与LaTex公式简介</a></li>
<li><a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">Mathjax</a></li>
<li><a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">LaTeX</a></li>
<li><a href="http://macdown.uranusjr.com" target="_blank" rel="external">MacDowm</a></li>
<li><a href="https://www.zybuluo.com/mdeditor#137019" target="_blank" rel="external">Cmd Markdown编辑阅读器</a></li>
<li>HTML标签<ul>
<li><a href="http://www.w3school.com.cn/html/html_fonts.asp" target="_blank" rel="external">HTML字体</a></li>
<li><a href="http://www.w3school.com.cn/tags/html_ref_colornames.asp" target="_blank" rel="external">HTML颜色</a></li>
<li><a href="http://www.w3school.com.cn/html/html_tables.asp" target="_blank" rel="external">HTML表格</a></li>
</ul>
</li>
<li>图床(七牛, ImageShack)</li>
<li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NextT-Github</a></li>
<li><a href="http://theme-next.iissnan.com" target="_blank" rel="external">NextT</a></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/04/06/Java_package, import/" itemprop="url">
                  Java package, import
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2014-04-06T00:00:00+09:00" content="2014-04-06">
              2014-04-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/04/06/Java_package, import/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/04/06/Java_package, import/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-package-import"><a href="#Java-package-import" class="headerlink" title="Java package, import"></a>Java package, import</h1><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><h3 id="package作用"><a href="#package作用" class="headerlink" title="package作用"></a>package作用</h3><p>Java引入包（package）机制，提供了类的多层命名空间，用于解决类的命名冲突、类文件管理等问题。</p>
<p>Java允许将一组功能相关的类放在同一个package下，从而组成逻辑上的类库单元。如果希望把一个类放在指定的包结构下，我应该在Java源程序的第一个非注释行放置如下格式的代码：</p>
<p><code>package packagename;</code></p>
<p>一旦在Java源文件中使用了这个package语句，就意味着该源文件里定义的所有类都属于这个包。位于包中的每个类的完整类名都应该是包名和类名的组合，如果其他人需要使用该包下的类，也应该使用包名加类名的组合。</p>
<h3 id="javac-d-Hello-java-与-javac-Hello-java-的区别？"><a href="#javac-d-Hello-java-与-javac-Hello-java-的区别？" class="headerlink" title="javac -d . Hello.java 与 javac Hello.java 的区别？"></a><code>javac -d . Hello.java</code> 与 <code>javac Hello.java</code> 的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package lee;</div><div class="line">public class Hello</div><div class="line">&#123;</div><div class="line">　　public static void main(String[] args)</div><div class="line">  &#123;</div><div class="line">　　System.out.println(&quot;Hello World!&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>-d</code>选项本来用于设置编译生成的class文件的保存位置，这里指定将生成的class文件放在当前路径下。<strong>使用该命令编译后，当前路径下生成一个名为lee的文件夹，该文件夹下则有一个Hello.class文件。</strong></p>
<p><strong>如果直接使用javac Hello.java命令编译，将会在当前路径下生成一个Hello.class文件，而不会生成lee文件夹。</strong></p>
<h3 id="同一个包中的类必须位于同一个文件夹吗？"><a href="#同一个包中的类必须位于同一个文件夹吗？" class="headerlink" title="同一个包中的类必须位于同一个文件夹吗？"></a>同一个包中的类必须位于同一个文件夹吗？</h3><p>可以不在同一个文件夹。例如lee.Person和lee.PersonTest两个类可一个在C盘一个在D盘，只要让CLASSPATH环境变量包含这两个路径即可。</p>
<h3 id="包名如何起？"><a href="#包名如何起？" class="headerlink" title="包名如何起？"></a>包名如何起？</h3><p>包名一般全是小写字母，由一个或多个有意义的单词连缀而成。为了在开发中避免包名和类名同时重复的情况，Oracle建议使用公司Internet域名倒写来作为包名，例如Internet域名是crazyit.org，则该公司的所有类都放在org.crazyit包及其子包下。<br>域名倒写.项目名.模块名.组件名</p>
<p>同一个包下的类互相访问时可以不加包前缀吗？<br>可以。</p>
<p>父包和子包互相访问时可以不加包前缀吗？<br>不可以，必须加包前缀。</p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><h3 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h3><p>正如上面看到的，如果需要使用不同包中的其他类时，总是需要使用该类的全名，这是一件繁琐的事情。为了简化编程，Java引入了import关键字，import关键字可以向某个java文件只能给导入指定包层次下的某个类或全部类，import语句应该出现在package语句之后、类定义之前。一个Java源文件只能包含一个package语句，但可以包含多个import语句，多个import语句用于导入多个包层次下的类。</p>
<p>导入单个类：import package.subpackage…ClassName;<br>导入全部类：import package.subpackage…*;</p>
<p>上面的（*）只能代表类，不能代表包。</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用“import”语句可完成此功能。在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为：<br>    <code>import package1[.package2…].(classname|*);</code><br>java 运行时环境将到 <code>CLASSPATH + package1.[package2…]</code>路径下寻找并载入相应的字节码文件 classname.class。“*”号为通配符，代表所有的类。也就是说 import 语句为编译器指明了寻找类的途径。</p>
<p>例，使用 import 语句引入类程序：TestPackage.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> p1.Test;    <span class="comment">//或者 import p1.*;</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPackage</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        Test t = <span class="keyword">new</span> Test(); <span class="comment">// Test 类在 p1 包中定义</span></div><div class="line">        t.display();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>java 编译器默认为所有的 java 程序引入了 JDK 的 java.lang 包中所有的类（import java.lang.*;），其中定义了一些常用类：System、String、Object、Math 等。因此我们可以直 接使用这些类而不必显式引入。但使用其它非无名包中的类则必须先引入、后使用。</p>
<h4 id="Java-类搜寻方式"><a href="#Java-类搜寻方式" class="headerlink" title="Java 类搜寻方式"></a>Java 类搜寻方式</h4><p>程序中的 import 语句标明要引入 p1 包中的 Test 类，假定环境变量 CLASSPATH 的值为“.;C:\jdk6\lib;D:\ex”，java 运行环境将依次到下述可能的位置寻找并载入该字节码文件 Test.class：<br>    .\p1\Test.class<br>    C:\jdk6\lib\p1\Test.class<br>    D:\ex\p1\Test.class<br>“.”代表当前路径，如果在第一个路径下就找到了所需的类文件，则停止搜索。否则依次搜索后续路径，如果在所有的路径中都未找到所需的类文件，则编译或运行出错。</p>
<h3 id="Java的常用包"><a href="#Java的常用包" class="headerlink" title="Java的常用包"></a>Java的常用包</h3><p>Java的核心类都放在java这个包及其子包下，Java扩展的许多类都放在javax包及其子包之下。这些实用类也就是前面所说的API（应用程序接口），Oracle按这些类的功能分别放在不同的包下。下面几个包是Java中的常用包。</p>
<p>java.lang：这个包下包含了Java语言的核心类，如Sting、Math、System、和Tread类等，使用这个包下的类无需使用import语句导入，系统会自动导入这个包下的所有类。<br>java.util：这个包下包含了Java的大量工具类/接口和集合框架类/接口，例如Arrays和List、Set等。<br>java.net：这个包下包含了一些Java网络编程相关的类/接口。<br>java.io：这个包下包含了一些Java输入/输出相关的类/接口。<br>java.text：这个包下包含了一些Java格式化相关的类。<br>java.sql：这个包下包含了一些Java进行JDBC数据库编程相关的类/接口。<br>java.awt：这个包下包含了抽象窗口工具集（Abstract Window Toolkits）的相关类/接口，这些类主要用于构建图形用户界面（GUI）程序。<br>java.swing：这个包下包含了Swing图形用户界面编程的相关类/接口，这些类可用于构建平台无关的CUI程序。</p>
<p>转自: <a href="http://www.cnblogs.com/sage-blog/p/3913906.html" target="_blank" rel="external">Java package详解</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/04/06/Java_package, import, path, classpath实例/" itemprop="url">
                  Java_package, import, path, classpath实例
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2014-04-06T00:00:00+09:00" content="2014-04-06">
              2014-04-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/04/06/Java_package, import, path, classpath实例/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/04/06/Java_package, import, path, classpath实例/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-classpath及package实例详解"><a href="#Java-classpath及package实例详解" class="headerlink" title="Java classpath及package实例详解"></a>Java classpath及package实例详解</h1><p>转自: <a href="http://www.blogjava.net/agassi-p/archive/2006/11/27/83764.html" target="_blank" rel="external">Java入门实例classpath及package详解</a></p>
<p>Java很诱人，但对于刚跨入Java门槛的初学者来说，编译并运行一个无比简单的Java程序简直就是一个恶梦。明明程序没错，但各种各样让人摸不着头脑的错误信息真的让你百思不得其解，许多在Java门口徘徊了很久的初学者就这样放弃了学习Java的机会，很是可惜。笔者也经历过这个无比痛苦的阶段，感觉到编译难的问题就出在classpath的设置及对package的理解之上。本文以实例的方式，逐一解决在编译过程中所出现的各种classpath的设置问题。本文实例运行的环境是在Windows XP + JDK 1.5.0。对其他的环境，读者应该很容易进行相应的转换。</p>
<ul>
<li><p>下载并安装JDK1.5.0，并按默认路径，安装到C:\Program Files\Java\jdk1.5.0中。</p>
</li>
<li><p>用鼠标单击WindowsXP的“开始”-&gt;“运行”，在弹出的运行窗口中输入cmd，按确定或回车，打开一个命令行窗口。</p>
</li>
<li><p>在命令行中输入：<code>java</code><br> 有一列长长的洋文滚了出来，这是JDK告诉我们java这个命令的使用方法。其中隐含了一个重要信息，即JDK安装成功，可以在命令行中使用java此命令了。</p>
</li>
<li><p>在命令行中输入 <code>javac</code><br> 屏幕显示：</p>
<p> ‘javac’ 不是内部或外部命令，也不是可运行的程序或批处理文件。</p>
<p> 这是由于windows找不到javac这个命令的原因。这就不明白了，java与javac都是JDK在同一个子目录里面的两个文件，为什么可以直接运行java而不能直接运行javac呢？原来，Sun公司为了方便大家在安装完JDK后马上就可以运行Java类文件，在后台悄悄地将java命令加入了Path的搜索路径中，因此我们可以直接运行java命令(但我们是看不到它到底是在哪设置的，无论是在用户的Path或系统的Path设置中均找不到这个java存放的路径)。但Sun所做的到此为止，其他JDK的命令，一概不管，需要由用户自己添加到搜索路径中。</p>
</li>
<li><p>既然如此，那我们自己添加Path的搜索路径吧。对“我的电脑”按右键，选“属性”，在“系统属性”窗口中选“高级”标签，再按“环境变量”按钮，弹出一个“环境变量”的窗口，在用户变量中新建一个变量，变量名为“Path”，变量值为”C:\Program Files\Java\jdk1.5.0\bin;%PATH%”。最后的%PATH%的意思是说，保留原有的Path设置，且将目前的Path设置新加到其前面。一路按“确定”退出(共有3次)。关掉原来的命令行窗口，依照第2步，重新打开一个新的命令行窗口。在此窗口中输入<code>javac</code>, 长长的洋文又出现了，这回是介绍javac的用法。设置成功。</p>
</li>
<li><p>So far so good. 到目前为止，我们已经可以编程了。但是，这不是一个好办法。因为随着以后我们深入学习Java，我们就会用到JUnit、Ant或NetBeans等应用工具，这些工具在安装时，都需要一个名为指向JDK路径的“JAVA_HOME”的环境变量，否则就安装不了。因此，我们需要改进第5步，为以后作好准备。依照第5步，弹出“环境变量”的窗口，在用户变量中新建一个变量，变量名为“JAVA_HOME”，变量值为”C:\Program Files\Java\jdk1.5.0”。注意，这里的变量值只到jdk1.5.0，不能延伸到bin中。确定后，返回“环境变量”的窗口，双击我们原先设定的Path变量，将其值修改为“%JAVA_HOME%\bin;%PATH%”。这种效果与第5步是完全一样的，只不过多了一个JAVA_HOME的变量。这样，以后当我们需要指向JDK的路径时，只需要加入“%JAVA_HOME%”就行了。至此，Path路径全部设置完毕。一路确定退出，打开新的命令行窗口，输入<code>javac</code></p>
<p> 如果长长的洋文出现，Path已经设置正确，一切正常。如果不是，请仔细检查本步骤是否完全设置正确。</p>
</li>
<li><p>开始编程。在C盘的根目录中新建一个子目录，名为“JavaTest”，以作为存放Java源代码的地方。打开XP中的记事本，先将其保存到JavaTest文件夹中，在“文件名”文本框中输入”Hello.java”。注意，在文件名的前后各加上一个双引号，否则，记事本就会将其存为”Hello.java.txt”的文本文件。然后输入以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  	System.out.println(<span class="string">"Hello, world"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  再次保存文件。</p>
</li>
<li><p>在命令行窗口中输入<br> <code>cd C:\JavaTest</code><br> 将当前路径转入JavaTest中。然后，输入<br> <code>javac Hello.java</code></p>
<p> JDK就在JavaTest文件夹中编译生成一个Hello.class的类文件。如果出现“1 error”或“XX errors”的字样，说明是源代码的输入有误，请根据出错提示，仔细地按第7步的代码找出并修正错误。请读者注意甄别代码输入有误的问题与classpath设置有误的问题。因为本文是关于如何正确设置classpath及package的，因此，这里假设读者输入的代码准确无误。到目前为此，由于我们是在源代码的当前路径下编译，因此，不会出现classpath设置有误的问题。</p>
</li>
<li><p>在命令行窗口中输入<br> <code>java Hello</code><br> 屏幕出现了<br> <code>Hello world</code></p>
<p> 成功了，我们已经顺利地编译及运行了第一个Java程序。</p>
<p> 但是，第8步及第9步是不完美的，因为我们是在JavaTest这个存放源码的文件夹中进行编译及运行的，因此，一些非常重要的问题并没有暴露出来。实际上，第8步的“javac Hello.java”及第9步的“java Hello”涉及到两个问题，一是操作系统如何寻找“javac”及“java”等命令，二是操作系统如何寻找“Hello.java”及“Hello.class”这些用户自己创建的文件。对于“javac”及“java”等命令，由于它们均是可执行文件，操作系统就会依据我们在第6步中设置好的Path路径中去寻找。而对于“Hello.java”及“Hello.class”这些文件，Path的设置不起作用。由于我们是在当前工作路径中工作，java及javac会在当前工作路径中寻找相应的java文件(class文件的寻找比较特殊，详见第11步)，因此一切正常。下面我们开始人为地将问题复杂化，在非当前工作路径中编译及运行，看看结果如何。</p>
</li>
<li><p>在命令行窗口中输入<code>cd C:</code><br> 转入到C盘根目录上，当前路径离开了存放源码的工作区。输入<br> <code>javac Hello.java</code></p>
<p> 屏幕出现：<br> <code>error: cannot read: Hello.java</code></p>
<p> 找不到Hello.java了。我们要给它指定一个路径，告诉它到C:\JavaTest去找Hello.java文件。输入<code>javac C:\JavaTest\Hello.java</code>. OK，这回不报错了，编译成功。</p>
</li>
<li><p>输入<code>java C:\JavaTest\Hello</code><br> 这回屏幕出现：<br> Exception in thread “main” java.lang.NoClassDefFoundError: C:\JavaTest\Hello<br> 意思为在“C:\JavaTest\Hello”找不到类的定义。明明C:\JavaTest\Hello是一个.class文件，为什么就找不到呢？原来，Java对待.java文件与.class文件是有区别的。对.java文件可以直接指定路径给它，而java命令所需的.class文件不能出现扩展名，也不能指定额外的路径给它。</p>
<p> 那么，如何指定路径呢？对于Java所需的.class文件，必须通过classpath来指定。</p>
</li>
<li><p>依照第5步，弹出“环境变量”窗口，在用户变量中新建一个变量，变量名为“classpath”，变量值为”C:\JavaTest”。一路按“确定”退出。关闭原命令行窗口，打开新的命令行窗口，输入<code>java Hello</code></p>
<p>“Hello world”出来了。由此可见，在“环境变量”窗口中设置classpath的目的就是告诉JDK，到哪里去寻找.class文件。这种方法一旦设置好，以后每次运行java或javac时，在需要调用.class文件时，JDK都会自动地来到这里寻找。因此，这是一个全局性的设置。</p>
</li>
<li><p>除了这种在环境变量”窗口中设置classpath的方法之外，还有另一种方法，即在java命令后面加上一个选项classpath，紧跟着不带扩展名的class文件名。例如，<br> <code>java -classpath C:\JavaTest Hello</code><br> JDK遇到这种情况时，先根据命令行中的classpath选项中指定的路径去寻找.class文件，找不到时再到全局的classpath环境变量中去寻找。这种情况下，即使是没有设置全局的classpath环境变量，由于已经在命令行中正确地指定类路径，也可以运行。</p>
<p> 为了在下面的例子中更好地演示classpath的问题，我们先将全局的classpath环境变量删除，而在必要时代之以命令行选项-classpath。弹出“环境变量”窗口，选中“classpath”的变量名，按“删除”键。</p>
<p> 此外，java命令中还可以用cp，即classpath的缩写来代替classpath，如java -cp C:\JavaTest Hello。特别注意的是，JDK 1.5.0之前，javac命令不能用cp来代替classpath，而只能用classpath。而在JDK 1.5.0中，java及javac都可以使用cp及classpath。因此，为保持一致，建议一概使用classpath作为选项名称。</p>
</li>
<li><p>我们再次人为地复杂化问题。关闭正在编辑Hello.java的记事本，然后将JavaTest文件夹名称改为带空格的“Java Test”。在命令行中输入<br><code>javac C:\Java Test\Hello.java</code></p>
<p>长长的洋文又出来了，但这回却是报错了：<br><code>javac: invalid flag: C:\Java</code></p>
<p>JDK将带有空格的C:\Java Test分隔为两部分”C:\Java”及”Test\Hello.java”，并将C:\Java视作为一个无效的选项了。这种情况下，我们需要将整个路径都加上双引号，即<br><code>javac &quot;C:\Java Test\Hello.java&quot;</code></p>
<p>这回JDK知道，引号里面的是一个完整的路径，因此就不会报错了。同样，对java命令也需要如此，即<br><code>java -classpath &quot;C:\Java Test&quot; Hello</code></p>
<p>对于长文件名及中文的文件夹，XP下面可以不加双引号。但一般来说，加双引号不容易出错，也容易理解，因此，建议在classpath选项中使用双引号。</p>
</li>
<li><p>我们再来看.java文件使用了其他类的情况。在C:\Java Test中新建一个Person.java文件，内容如下：</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，修改Hello.java，内容如下：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Mike"</span>);</div><div class="line">    System.out.println(person.getName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在命令行输入<br><code>javac &quot;C:\Java Test\Hello.java&quot;</code><br>错误来了：<br><code>C:\Java Test\Hello.java:3: cannot find symbol</code></p>
<p>   JDK提示找不到Person类。为什么javac “C:\Java Test\Hello.java”在第14步中可行，而在这里却不行了呢？第14步中的Hello.java文件并没有用来其他类，因此，JDK不需要去寻找其他类，而到了这里，我们修改了Hello.java，让其使用了一个Person类。根据第11步，我们需要告诉JDK，到哪里去找所用到的类，即使这个被使用的类就与Hello.java一起，同在C:\Java Test下面！输入<br><code>javac -classpath &quot;C:\Java Test&quot; &quot;C:\Java Test\Hello.java&quot;</code></p>
<p>  编译通过，JDK在C:\Java Test文件夹下同时生成了Hello.class及Person.class两个文件。实际上，由于Hello.java使用了Person.java类，JDK先编译生成了Person.class，然后再编译生成Hello.class。因此，不管Hello.java这个主类使用了多少个其他类，只要编译这个类，JDK就会自动编译其他类，很方便。输入<code>java -classpath &quot;C:\Java Test&quot; Hello</code>。成功。</p>
<ul>
<li><p>上几步步说明了在Hello.java中如何使用一个我们自己创建的Person.java，而且这个类与Hello.java是同在一个文件夹下。在这一步中，我们将考查Person.java如果放在不同文件夹下面的情况。</p>
<p>先将C:\Java Test文件夹下的Person.class文件删除，然后在C:\Java Test文件夹下新建一个名为DF的文件夹，并将C:\Java Test文件夹下的Person.java移动到其下面。在命令行输入<br><code>javac -classpath &quot;C:\Java Test\DF&quot; &quot;C:\Java Test\Hello.java&quot;</code></p>
<p>  编译通过。这时javac命令没有什么不同，只需将classpath改成C:\Java Test\DF就行了。</p>
<p>  在命令行输入<br>  <code>java -classpath &quot;C:\Java Test&quot; Hello</code></p>
<p> 这时由于Java需要找在不同文件夹下的两个.class文件，而命令行中只告诉JDK一个路径，即C:\Java Test，在此文件夹下，只能找到Hello.class，找不到Person.class文件，因此，错误是可以预料得到的：</p>
<p>  Exception in thread “main” java.lang.NoClassDefFoundError: Person</p>
<pre><code>at Hello.main(Hello.java:3)
</code></pre><p> 果真找不到Person.class。在设置两个以上的classpath时，先将每个路径以双引号引起来，再将这些路径以“;”号隔开，并且每个路径与“;”之间不能带有空格。因此，我们在命令行重新输入：<br> <code>java -classpath &quot;C:\Java Test&quot;;&quot;C:\Java Test\DF&quot; Hello</code></p>
<p> 编译成功。但也暴露出一个问题，如果我们需要用到许多分处于不同文件夹下的类，那这个classpath的设置岂不是很长！有没有办法，对于一个文件夹下的所有.class文件，只指定这个文件夹的classpath，然后让JDK自动搜索此文件夹下面所有相应的路径？有，只要使用package。</p>
</li>
<li><p>package简介。Java中引入package的概念，主要是为了解决命名冲突的问题。比如说，在我们的例子中，我们设计了一个很简单的Person类，如果某人开发了一个类库，其中恰巧也有一个Person类，当我们使用这个类库时，两个Person类出现了命名冲突，JDK不知道我们到底要使用哪个Person类。更有甚者，当我们也开发了一个很庞大的类库，无可避免地，我们的类库中与其他人开发的类库中命名冲突的情况就会越来越多。总不能为了避免自己的类名与其他人开发的类名相同，而让每个编程人员都绞尽脑汁地将一个本应叫Writer的类强行改名为SarkuyaWriter，MikeWriter, SmithWriter吧？</p>
<p>现实生活中也是如此。假如你名叫张三，又假如与你同一单位的人中有好几个都叫张三，那你的问题就来了。某天单位领导在会上宣布，张三被任命为办公室主任，你简直不知道是该哭还是该笑。但如果你的单位中只有你叫张三，你才不会在乎全国叫张三的人有多少个，因为其他张三都分布在全国各地、其他城市，你看不见他们，摸不着他们，自然不会担心。</p>
<p>Sun从这个“张三问题”受到了很大的启发，为解决命名冲突问题，就采取了“眼不见心不烦”的策略：将每个类都归属到一个特定的区域中，在同一个区域中的所有类，都不允许同名；而不同区域的类，由于相互看不到，则允许有同名的类存在。这样，就解决了命名冲突的问题，正如北京的张三与上海的张三毕竟不是同一人。这个区域在Java中就叫package。由于package在Java中非常重要，如果你没有定义自己的package，JDK将会你的类都归到一个默认的无名package中。</p>
<p>自定义package的名称可以由各个程序员自由创建。作为避免命名冲突的手段，package的名称最好足以与其他程序员的区别开来。在互联网上，每个域名都是唯一的，因此，Sun推荐将你自己的域名倒写后作为package的名称。如果你没有自己的域名，很可能只是因为囊中羞涩而不去申请罢了，并不见得你假想的域名与其他域名发生冲突。例如，笔者假想的域名是sarkuya.com，目前就是唯一的，因此我的package就可以定名为com.sarkuya。谢谢Java给了我们一个免费使用我们自己域名的机会，唯一的前提是倒着写。当然，每个package下面还可以带有不同的子package，如com.sarkuya.util，com.sarkuya.swing，等等。</p>
<p>定义package的方式是在相应的.java文件的第一行加上“package packagename;”的字样，而且每个.java文件只能有一个package。实际上，Java中的package的实现是与计算机文件系统相结合的，即你有什么样的package，在硬盘上就有什么样的存放路径。例如，某个类的package名为com.sarkuya.util，那么，这个类就应该必须存放在com/sarkuya/util的路径下面。至于这个com/sarkuya/util又是哪个文件夹的子路径，第18步会谈到。</p>
<p>package除了有避免命名冲突的问题外，还引申出一个保护当前package下所有类文件的功能，主要通过为类定义几种可视度不同的修饰符来实现：public, protected, private, 另外加上一个并不真实存在的friendly类型。</p>
<p>对于冠以public的类、类属变量及方法，包内及包外的任何类均可以访问；<br>protected的类、类属变量及方法，包内的任何类，及包外的那些继承了此类的子类才能访问；<br>private的类、类属变量及方法，包内包外的任何类均不能访问；<br>如果一个类、类属变量及方法不以这三种修饰符来修饰，它就是friendly类型的，那么包内的任何类都可以访问它，而包外的任何类都不能访问它(包括包外继承了此类的子类)，因此，这种类、类属变量及方法对包内的其他类是友好的，开放的，而对包外的其他类是关闭的。</p>
<p>前面说过，package主要是为了解决命名冲突的问题，因此，处在不同的包里面的类根本不用担心与其他包的类名发生冲突，因为JDK在默认情况下只使用本包下面的类，对于其他包，JDK一概视而不见：“眼不见心不烦”。如果要引用其他包的类，就必须通过import来引入其他包中相应的类。只有在这时，JDK才会进行进一步的审查，即根据其他包中的这些类、类属变量及方法的可视度来审查是否符合使用要求。如果此审查通不过，编译就此卡住，直至你放弃使用这些类、类属变量及方法，或者将被引入的类、类属变量及方法的修饰符改为符合要求为止。如果此审查通过，JDK最后进行命名是否冲突的审查。如果发现命名冲突，你可以通过在代码中引用全名的方式来显式地引用相应的类，如使用<br><code>java.util.Date = new java.util.Date()</code></p>
<p>或是<br><code>java.sql.Date = new java.sql.Date()。</code></p>
<p>package的第三大作用是简化classpath的设置。还记得第16步中的障碍吗？这里重新引用其java命令：<br><code>java -classpath &quot;C:\Java Test&quot;;&quot;C:\Java Test\DF&quot; Hello</code></p>
<p>我们必须将所有的.class文件的路径一一告诉JDK，而不管DF其实就是C:\Java Test的子目录。如果要用到100个不同路径的.class文件，我们就得将classpath设置为一个特别长的字符串，很累。package的引入，很好地解决了这个问题。package的与classpath相结合，通过import指令为中介，将原来必须由classpath完成的类路径搜索功能，很巧妙地转移到import的身上，从而使classpath的设置简洁明了。我们先看下面的例子。</p>
</li>
<li><p>先在Hello.java中导入DF.Person。代码修改如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">import</span> DF.Person;</div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Mike"</span>);</div><div class="line">    System.out.println(person.getName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再将DF子文件夹中的Person.java设置一个DF包。代码修改如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">package</span> DF;</div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> String name;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">  javac -classpath <span class="string">"C:\Java Test"</span> <span class="string">"C:\Java Test\Hello.java"</span></div><div class="line">java -classpath <span class="string">"C:\Java Test"</span> Hello</div></pre></td></tr></table></figure>
</li>
</ul>
<p>  尽管这次我们只设置了C:\Java Test的classpath，但编译及运行居然都通过了！事实上，Java在搜索.class文件时，共有三种方法：<br>一是全局性的设置，详见第12步，其优点是一次设置，每次使用；<br>二是在每次的javac及java命令行中自行设置classpath，这也是本文使用最多的一种方式，其优点是不加重系统环境变量的负担；<br>三是根据import指令，将其内容在后台转换为classpath。JDK将读取全局的环境变量classpath及命令行中的classpath选项信息，然后将每条classpath与经过转换为路径形式的import的内容相合并，从而形成最终的classpath. 在我们的例子中，JDK读取全局的环境变量classpath及命令行中的classpath选项信息，得到C:\Java Test。接着，将import DF.Person中的内容，即DF.Person转换为DF\Person, 然后将C:\Java Test与其合并，成为C:\Java Test\DF\Person，这就是我们所需要的Person.class的路径。在Hello.java中有多少条import语句，就自动进行多少次这样的转换。而我们在命令行中只需告诉JDK最顶层的classpath就行了，剩下的则由各个类中的import指令代为操劳了。这种移花接木的作法为我们在命令行中手工地设置classpath提供了极大的便利。</p>
<p> 应注意的一点是，import指令是与package配套使用的，只有在某类通过“package pacakgename;”设定了包名后，才能给其他类通过import指令导入。如果import试图导入一个尚未设置包的类，JVM就会报错。</p>
<ul>
<li><p>我们接下来看，当使用JDK类库时，classpath如何设置。</p>
</li>
<li><p>修改Hello.java，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> DF.Person;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Date date = <span class="keyword">new</span> Date();</div><div class="line">    System.out.println(date);</div><div class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Mike"</span>);</div><div class="line">    System.out.println(person.getName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>JDK类库存放于C:\Program Files\Java\jdk1.5.0\jre\lib\rt.jar文件中。关于jar文件的介绍，已经超出了本文的范围，感兴趣的读者可以阅读Horstmann写的Core Java一书。</p>
<p>jar文件可以用WinRar打开。用WinRar打开后，可以看到里面有一些文件夹，双击其中的java文件夹，再双击util的文件夹，可以在看到Date.class文件就在其中。如果你看过Data.java或其他JDK类库的源码(在C:\Program Files\Java\jdk1.5.0\src.zip文件中)，你就会发现，像java、util这些文件夹均是package。这也是Hello.java第2行中使用了import指令的原因。</p>
<p>我们可以通过WinRar的查找功能来定位某个类所在的包。在“查找文件”的窗口中的“要查找的文件名”文本框中输入Date.class，就会查找出在rt.jar文件中存在两个Date.class文件，一个是java\sql\Date.class，另一个是java\util\Date.class。其中，sql下面的Date.class文件与数据库有关，并非我们这里所需，java\util\Date.class才是我们所要的。</p>
<p>rt.jar文件就像本文中的C:\Java Test中一样，是JDK类库的唯一入口。我们可以在命令行的classpath选项指定.jar文件。需要注意，.jar文件的classpath设置有些特珠。在以前的例子中，我们设置classpath时都是设置了路径就行了，而对于.jar文件，我们必须将.jar文件名直接加到classpath中。</p>
</li>
<li><p>在命令行输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  javac -classpath &quot;C:\Program Files\Java\jdk1.5.0\jre\lib\rt.jar&quot;;&quot;C:\Java Test&quot; &quot;C:\Java Test\Hello.java&quot;</div><div class="line">java -classpath &quot;C:\Program Files\Java\jdk1.5.0\jre\lib\rt.jar&quot;;&quot;C:\Java Test&quot; Hello</div></pre></td></tr></table></figure>
<p>这样当然没有问题，因为我们指定了rt.jar文件及C:\Java Test两个classpath。但且慢，在命令行输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">javac -classpath &quot;C:\Java Test&quot; &quot;C:\Java Test\Hello.java&quot;</div><div class="line">java -classpath &quot;C:\Java Test&quot; Hello</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不可思议的是，编译及运行成功了！令人惊讶的是在我们将classspath只设置为C:\Java Test的情况下，JDK如何得出java.util.Date的classpath？</p>
<p>  原因在于，就像java的Path路径已经悄悄在后台设置好一样，rt.jar的classpath路径也悄悄地在后台设置了。因此，我们不必多此一举手工设置其classpath了。</p>
<ul>
<li><p>最后一点需要谈到的是，如果主类恰好也在一个package中(在大型的开发中，其实这才是一种最常见的现象)，那么java命令行的类名前面就必须加上包名。</p>
<p>在C:\Java Test下面新建一个文件夹，名为NF。将C:\Java Test下面的Hello.class删除，将Hello.java移到NF文件夹下。打开NF文件夹下的Hello.java，为其设置package属性。</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> NF;</div><div class="line"><span class="keyword">import</span> DF.Person;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Date date = <span class="keyword">new</span> Date();</div><div class="line">    System.out.println(date);</div><div class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Mike"</span>);</div><div class="line">    System.out.println(person.getName());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译与以前没啥区别，只不过是修正一下改过之后的路径。<br><code>javac -classpath &quot;C:\Java Test&quot; &quot;C:\Java Test\NF\Hello.java&quot;</code></p>
<p>  而java命令行却有了变化<br>  <code>java -classpath &quot;C:\Java Test&quot; NF.Hello</code></p>
<p>  上面命令行语句中，NF.Hello告诉JDK，Hello.class在NF的package下面。</p>
<p>  至此，本文有关classpath及package的问题的讨论已经全部结束。由此可见，Java的入门的确非常不易。如果初学Java的程序员一见到Java的编译竟是如此的复杂，多半就会抽身而退。因此，笔者认为，Sun在J2SE的Tutorial中故意将编译的问题尽量简单化，以吸引更多的Java初学者。一旦品尝了Java的香醇可口的美味后，就不用担心他们退出了，因为咖啡是非常容易让人上瘾的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/04/05/Java_classpath,path,JAVA_HOME/" itemprop="url">
                  CLASSPATH、PATH、JAVA_HOME的作用及JAVA环境变量配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2014-04-05T00:00:00+09:00" content="2014-04-05">
              2014-04-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/04/05/Java_classpath,path,JAVA_HOME/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/04/05/Java_classpath,path,JAVA_HOME/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CLASSPATH、PATH、JAVA-HOME的作用及JAVA环境变量配置"><a href="#CLASSPATH、PATH、JAVA-HOME的作用及JAVA环境变量配置" class="headerlink" title="CLASSPATH、PATH、JAVA_HOME的作用及JAVA环境变量配置"></a>CLASSPATH、PATH、JAVA_HOME的作用及JAVA环境变量配置</h1><h2 id="CLASSPATH"><a href="#CLASSPATH" class="headerlink" title="CLASSPATH"></a>CLASSPATH</h2><p>它是javac编译器的一个环境变量。用与<code>import、package</code>关键字有关。作用是指定类搜索路径，要使用已经编写好的类，前提当然是能够找到它们了，JVM就是通过CLASSPATH来寻找类的。我们需要把jdk安装目录下的lib子目录中的dt.jar和tools.jar设置到CLASSPATH中，当然，当前目录“.”也必须加入到该变量中。这里<code>CLASSPATH</code>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">.;C:/Program Files/Java/jdk1.6.0_21/lib/dt.jar;C:/Program Files/Java/</div><div class="line">jdk1.6.0_21/lib/tools.jar</div></pre></td></tr></table></figure>
<p>当写下<code>import java.util.*</code>时，编译器面对import关键字时，就知道你要引入java.util这个package中的类,但是编译器如何知道你把这个package放在哪里了呢？所以你首先得告诉编译器这个package的所在位置；如何告诉它呢？就是设置<code>CLASSPATH</code>啦.</p>
<p>如果java.util这个package在c:/jdk/ 目录下，你得把c:/jdk/这个路径设置到CLASSPATH中去！当编译器面对<code>import java.util.*</code>这个语句时，它先会查找CLASSPATH所指定的目录，并检视子目录java/util是否存在，然后找出名称吻合的已编译文件（.class文件）。如果没有找到就会报错！</p>
<p>当你自己开发一个package时，然后想要用这个package中的类；自然，你也得把这个package所在的目录设置到<code>CLASSPATH</code>中去！<code>CLASSPATH</code>的设定，对JAVA的初学者而言是一件棘手的事。所以Sun让JAVA2的JDK更聪明一些。你会发现，在你安装之后，即使完全没有设定CLASSPATH，你仍然能够编译基本的JAVA程序，并且加以执行。</p>
<p><strong>配置</strong></p>
<p>对于Windows系统而言，名为Path的系统环境变量已经存在，可以直接修改该环境变量，在该环境变量值后面追加如   <code>D:\Java\jdk1.7.0\bin</code>（JDK的安装路径）。或者新建一个名为PATH的环境变量，设置它的值为 <code>D:\Java\jdk1.7.0\bin</code></p>
<p>Linux平台下的环境变量是通过 <code>.bash_profile</code> 文件来设置的。在该文件的PATH变量后面添加：<code>/home/Java/jdk1.7.0 /bin</code>（JDK安装路径）</p>
<p><code>PATH= .:PATH:HOME/bin : /home/Java/jdk1.7.0/bin</code></p>
<p>完成了PATH变量的设置后，在 <code>.bash_profile</code> 文件最后添加导出PATH变量的语句</p>
<p><code>export PATH</code></p>
<p>重新登陆Linux或执行如下命令让文件中的PATH变量生效：</p>
<p><code>source .bash_profile</code></p>
<h2 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h2><p>PATH环境变量。作用是指定命令搜索路径.</p>
<p>在命令行下面执行命令如javac编译java程序时，它会到PATH变量所指定的路径中查找看是否能找到相应的命令程序。</p>
<p>我们需要把jdk安装目录下的bin目录增加到现有的PATH变量中，bin目录中包含经常要用到的可执行文件如<code>javac/java/javadoc</code>等，设置好PATH变量后，就可以在任何目录下执行javac/java等工具了。我们这里设定的PATH值为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">%SystemRoot%/system32;%SystemRoot%;%SystemRoot%/System32/Wbem;%SYSTEMROOT%/</div><div class="line">System32/WindowsPowerShell/v1.0/;C:/Program Files/Common Files/Thunder </div><div class="line">Network/KanKan/Codecs;C:/Program Files/Microsoft SQL Server/90/Tools/</div><div class="line">binn/;C:/Program Files/Common Files/TTKN/Bin;C:/Program Files/Common Files/</div><div class="line">Teleca Shared;C:/Program Files/Java/jdk1.6.0_21/bin</div></pre></td></tr></table></figure>
<font color="red"> C:/Program Files/Java/jdk1.6.0_21/bin </font>

<p>上述只有红色部分<code>;C:/Program Files/Java/jdk1.6.0_21/bin</code>是java的PATH变量，注意变量之间需要用”;”隔开。</p>
<p><strong>如果想在运行Java时临时指定JRE搜索Java类的路径</strong>，可以使用 -classpath 选项，Linux上用冒号（:）隔开</p>
<p><code>java -classpath dir1;dir2,...;dirN  Java类</code><br>或者<br><code>java -classpath %CLASSPATH%;.;dir1;dir2,...;dirN  Java类</code></p>
<h2 id="JAVA-HOME"><a href="#JAVA-HOME" class="headerlink" title="JAVA_HOME"></a>JAVA_HOME</h2><p><code>JAVA_HOME</code>环境变量，指向jdk的安装目录，Eclipse/NetBeans/Tomcat等软件就是通过搜索<code>JAVA_HOME</code>变量来找到并使用安装好的jdk。这里JAVA_HOME为：</p>
<p><code>C:/Program Files/Java/jdk1.6.0_21</code></p>
<p>转自: <a href="http://www.cnblogs.com/xwdreamer/archive/2010/09/08/2297098.html" target="_blank" rel="external">CLASSPATH、PATH、JAVA_HOME的作用及JAVA环境变量配置</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/65/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/65/">65</a><span class="page-number current">66</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/plusaber.jpg"
               alt="Plusaber" />
          <p class="site-author-name" itemprop="name">Plusaber</p>
          <p class="site-description motion-element" itemprop="description">Plusaber's Blog</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">330</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分類</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">52</span>
                <span class="site-state-item-name">標籤</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.kaggle.com" title="Kaggle" target="_blank">Kaggle</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.algolia.com" title="Algolia" target="_blank">Algolia</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://jp.linkedin.com/in/zebangchen" title="LinkedIn" target="_blank">LinkedIn</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://portal.qiniu.com" title="Qiniu" target="_blank">Qiniu</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plusaber</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'plusaber';
      var disqus_identifier = 'page/66/index.html';
      var disqus_title = "";
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  




  
  

  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>
  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

  

  


</body>
</html>
